# bcdk Tutorial


### Concepts

#### Infrastructure as Code

One of the key concepts of the `BCDK` tools is the idea of `Infrastructure as Code`.  What this mean is that any tools that support building, testing and deploying you application are also part of your code base in the version control repository.  This means that you would have a single software repository (GitHub Repository) which will contain not only your application code but also any code for tools needed to build and deploy your application.  Prime examples of infrastructure tools needed to support your application build/deploy cycle are Jenkins, Sonarqube, etc.  

#### Modules

To support the concept of `Infrastructure as Code`, the `bcdk` tool makes the distinction between one or more infrastructure tools and your application in the version control repository using the term `module`.  You can think about the modules in your source code repository as being either an `infrastructure module` or an `application module`.  In the source version control repository, one `module` is your application code.  Another `module` could be Jenkins and yet another `module` could be Sonarqube. Each `module` is considered a separate item in that they have their own build and deploy schedule.  This is manifest is Openshift as distinct Build and Deployment artifacts for each `module` in the repository.

#### Components

Each `module` will have one or more `components`.  For example, the default Jenkins `module`, created by the BCDK generator (see below), has 2 components that are build and deployed.  These components are a Jenkins master and a slave instance.  Each `component` of a `module`, is has it's own Openshift build configuration file and deployment configuration file in the `openshift` directory.  For the module build, each of these components is listed as an object in the `lib/build.js` file used orchestrate the `module` build.

#### Pull Request Pipelines

The `bcdk` implements Pull Request Pipelines for every `module` in your source code repository.  A Pull Request Pipeline is defined in Jenkins for every `module` in the repository (including Jenkins itself) and is used to build and deploy that `module`.  The trigger for the executing the pipeline is, as you might have guessed, a pull request.  In GitHub, the `bcdk` configures Webhooks in the source repository which fire based on various 'events' that happen in the repository.  One such event is a Pull Request.  Following the [GitHub Flow](https://guides.github.com/introduction/flow/), a developer branches from `master` and works on the new feature branch.  When the feature is ready for review, the developer creates a pull request.  The repository has some Webhooks configured by the `bcdk` jenkins `module`, the pull request event will fire one of these Webhooks which will notify Jenkins of the pull request and Jenkins will start the pull request pipeline for every `module` in the source code repository, including Jenkins itself.  It gets a little like [Inception](https://www.imdb.com/title/tt1375666/) here because Jenkins manages it's own pull request pipeline and will re-build and re-deploy itself if there is a change in the pull request that affects the configuration of Jenkins.  

### Installation

See the `README.md` for details on installing the `bcdk` on your computer.

### BCDK Generators

Once `bcdk` is installed you can see the list of available generators.

```bash
yo bcdk --generators
```

Generators provide a scaffolding for your project `modules` to help you get off to a faster start.  For example, the `bdck:jenkins` generator provides an opinionated scaffolding for setting up Jenkins as an infrastructure `module` in your project source repository.  The generator creates a `.jenkins` folder at the root of your source repository.  Here are the files generated by running this generator.

```bash
.
├── .jenkins
│   ├── .pipeline
│   │   ├── build.js
│   │   ├── clean.js
│   │   ├── deploy.js
│   │   ├── lib
│   │   │   ├── build.js
│   │   │   ├── clean.js
│   │   │   ├── config.js
│   │   │   └── deploy.js
│   │   ├── npmw
│   │   ├── package-lock.json
│   │   └── package.json
│   ├── Jenkinsfile
│   ├── README.md
│   ├── docker
│   │   ├── Dockerfile
│   │   └── contrib
│   │       └── jenkins
│   │           └── configuration
│   │               └── jobs
│   │                   └── _jenkins
│   │                       └── config.xml
│   └── openshift
│       ├── build-master.yaml
│       ├── build-slave.yaml
│       ├── deploy-master.yaml
│       ├── deploy-prereq.yaml
│       ├── deploy-slave.yaml
│       └── secrets.json
└── .yo-rc.json
```

A less opinionated generator is the `bcdk:pipeline` which will create a basic scaffolding for your application `module`.  It requires that your DevOps team modify the files in the scaffolding to configure it correctly for the application `module` that you wish to build/deploy using the `bcdk` tooling.  Here are the files generated by running this generator.

```bash
.
├── .pipeline
│   ├── build.js
│   ├── clean.js
│   ├── deploy.js
│   ├── lib
│   │   ├── build.js
│   │   ├── clean.js
│   │   ├── config.js
│   │   └── deploy.js
│   ├── npmw
│   ├── package-lock.json
│   └── package.json
├── .yo-rc.json
└── Jenkinsfile
```

The `bcdk` provides generator for a simple sample application that you can use to try out the `bcdk` Pull Request pipeline approach.  This tutorial will use this generator to demonstrate the workflow involved in using the `bcdk` tools for application builds and deployments that are driven by pull requests.

See the `README.md` for details about each generator

### Workflow

#### Prerequisites

+ `npm` is installed on your local developer workstation/laptop
+ `bcdk` is installed on your local developer workstation/laptop
+ You have a GitHub account and have created a personal access token for that account.
+ You have a set of Openshift namespaces that will be used for builds/deploys of application modules

### Building and deploying the sample application

1. Create a new repository called `python-hello` in your account GitHub.
2. Clone to your local system and change directory into the new empty repo.

```bash
  git clone https://github.com/david-kerins/python-hello.git
  cd python-hello
```

3. Create a new feature branch from `master`

```bash
  git checkout -b feature/setup-bcdk-jenkins
```

4. Login to Pathfinder (or your Openshift cluster) and run the `bdck:jenkins` generator.  Follow the prompts.

```bash
  oc login https://ocp.bitbox.ca:8443 --token=KhMBp76_OYYemFsSMP-vKXTgC4kKedtsipYxO6f2HX0
  yo bcdk:jenkins
```

  *You should answer the prompts as follows but using your own information for openshift `tools` namespace, github info, etc.*

----

  You are authenticated in OpenShift as david-kerins

  What is your openshift 'tools' namespace name? `gtncer-tools`

  One or more required secrets are missing.
  We will need a GitHub username. We strongly recommend creating an account shared with the team for CI/CD/Automation purposes. `david-kerins`

  What is the personal access token for the GitHub account?
   See https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line
   Required priveleges: public_repo, repo:status, repo_deployment, admin:repo_hook [hidden]

  Setting module

  What is this module name? `jenkins`
  
  What is this module version? `1.0.0`
  
  What environments are supported by your app? separated by space `build dev prod`
  
  What is the source code directory for this module? `.jenkins`
  
  What namespace/project name is used for 'build?' `gtncer-tools`
  
  What namespace/project name is used for 'dev?' `gtncer-tools`
  
  What namespace/project name is used for 'prod?' `gtncer-tools`
  
  What is the GitHub organization where the repository is located? `david-kerins`
  
  What is the repository's name? `python-hello`
  
  What is the Jenkinsfile path? `.jenkins/Jenkinsfile`

----

5. Commit and push to GitHub

```bash
git add --all
git commit -m"Initial commit of Jenkins module"
git push --set-upstream origin feature/setup-bcdk-jenkins
```

6. Change directories into the Jenkins `module` folder, run npm install

```bash
  cd .jenkins/.pipeline/
  npm i
```

7. Run the build for Jenkins.

```bash
  npm run build -- --pr=0 --dev-mode=true
```

*Since we are bootstrapping Jenkins for the first time we use a couple of flags `--pr=0 --dev-mode=true`.  We give it a initial pull request number of '0' and use the 'dev-mode' flag to have it build using local files rather than looking to Github.*

If everything worked, there should be two build configurations on the Openshift `tools` namespace, one build for the Jenkins master and one for the Jenkins slave, plus build images for them.

```bash
oc get bc
NAME                         TYPE     FROM                   LATEST
jenkins-build-0              Docker   Git@refs/pull/0/head   1
jenkins-slave-main-build-0   Docker   Dockerfile             1

oc get is
NAME               DOCKER REPO                                                      TAGS          UPDATED
jenkins            docker-registry.default.svc:5000/gtncer-tools/jenkins            build-1.0.0-0 5 minutes ago
jenkins-slave-main docker-registry.default.svc:5000/gtncer-tools/jenkins-slave-main build-1.0.0-0 4 minutes ago
```

8. Run the deploy for the 'dev' instance of Jenkins

```bash
npm run deploy -- --pr=0 --env=dev
```

